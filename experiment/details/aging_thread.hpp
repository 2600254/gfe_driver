/**
 * Copyright (C) 2019 Dean De Leo, email: dleo[at]cwi.nl
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#pragma once

#include <cinttypes>
#include <condition_variable>
#include <future>
#include <mutex>
#include <random>
#include <unordered_map>
#include <vector>

#include <gmpxx.h> // libgmp

#include "aging_operation.hpp"
#include "aging_partition.hpp"
#include "common/circular_array.hpp"
#include "graph/edge.hpp"

// forward declarations
namespace experiment { class Aging; }
namespace experiment::details { class AsyncBatch; }
namespace library { class UpdateInterface; }

namespace experiment::details {

// A single worker thread in the aging experiment
class AgingThread {
    Aging* m_instance; // aging instance
    library::UpdateInterface* m_interface; // the graph library we are operating on
    const int m_worker_id; // the id of this thread
    const bool m_is_undirected; // is the graph undirected?

    std::vector<AgingPartition> m_partitions;
    uint64_t m_num_src_vertices_in_partitions {0};

    std::vector<graph::WeightedEdge> m_edges; // primary edges to insert in the final graph
    uint64_t m_final_edges_current_position { 0 }; // index to keep track up to where which edges have been inserted

    std::unordered_map<graph::Edge, bool> m_edges_already_inserted; // keep track of which edges have already been inserted
    common::CircularArray<graph::Edge> m_edges2remove; // edges that have been inserted but do not belong to the final graph

    AsyncBatch* m_batch; // send the edge updates in batches

    // synchronisation with the master thread
    AgingOperation m_current_operation { AgingOperation::NONE }; // the current operation the thread is performing
    std::promise<void> m_callback;
    std::mutex m_mutex_op;
    std::condition_variable m_condvar_op;

    std::mt19937_64 m_random { std::random_device{}() };
    std::uniform_real_distribution<double> m_uniform{ 0., 1. };

    // arbitrary precision arithmetic
    mpz_class* m_num_edges_in_partition { nullptr } ; // array of size m_partitions.size(), containing the max number of edges per partition

    AgingPartition m_interval_vertices2remove { 0, 0 };

    // Transform a relative source id (randomly generated) into an absolute edge id, according to the handled partitions
    uint64_t src_rel2abs(uint64_t relative_vertex_id) const;

    // How many edges do we still of the final graph do we still need to insert
    int64_t missing_edges_final() const;

    // Insert the given edge
    void insert_edge(graph::WeightedEdge edge);

    // Remove the given edge
    void remove_edge(graph::Edge edge);

    // Remove the temporary edge at the head of the queue m_edges2remove
    void remove_temporary_edge();

    // Total number of edges that can be generated by this worker, assuming the graph is undirected
    mpz_class get_num_edges_in_my_partitions() const;

    // Transform the given edge id in the vertex ids src/dst
    void edge_id_2_vertices_id(const mpz_class& edge_id, uint64_t* out_src_id, uint64_t* out_dst_id);

    // Check whether the given vertex id (src) belongs to the set of partitions to handle
    bool vertex_belongs(uint64_t vertex_id) const;

    // Generate a random number in [0, 1]
    double random01() noexcept;

    // Is the graph undirected?
    bool is_undirected() const { return m_is_undirected; }

    // Flush the current batch of updates & reset the variable batch_pos to 0
    void batch_flush();

    // Logic to run the experiment
    void main_experiment();

public:
    // Initialise the worker with the list of partitions in the adjacency matrix to handle
    AgingThread(Aging* instance, const std::vector<AgingPartition>& partitions, int worker_id);

    // Destructor
    ~AgingThread();

    // Execute a single operation in the thread
    std::future<void> execute(AgingOperation operation);

    // Controller thread, sync with the caller
    void main_thread();

    // The last pass for this class is REMOVE_VERTICES, which requires to remove all vertices from the interface/library as set in the
    // array m_instance->m_vertices2remove in the given interval [start, start +length).
    void set_partition_vertices_to_remove(uint64_t start, uint64_t length);
};

} // namespace

